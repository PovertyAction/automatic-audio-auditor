# Reference and setup https://github.com/Azure-Samples/cognitive-services-speech-sdk/tree/master/samples/batch/python

#!/usr/bin/env python
# coding: utf-8

# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE.md file in the project root for full license information.

import logging
import sys
import requests
import time
import swagger_client as cris_client
from datetime import datetime, timedelta
from azure.storage.blob import BlobServiceClient, generate_container_sas, generate_blob_sas, ContainerSasPermissions

logging.basicConfig(level=logging.DEBUG,
        format="%(asctime)s %(message)s", datefmt="%m/%d/%Y %I:%M:%S %p %Z", filename="batch_transcribe_log.txt")#stream=sys.stdout,

# Your subscription key and region for the speech service
from .azure_keys import get_speech_key, get_service_region, get_connection_string

debugging = True

SUBSCRIPTION_KEY = get_speech_key()
SERVICE_REGION = get_service_region()

NAME = "Simple transcription"
DESCRIPTION = "Simple transcription description"

# Set model information when doing transcription with custom models
MODEL_REFERENCE = None  # guid of a custom model


def transcribe_from_single_blob(uri, properties, locale):
    """
    Transcribe a single audio file located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    transcription_definition = cris_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=locale,
        content_urls=[uri],
        properties=properties
    )

    return transcription_definition


def transcribe_with_custom_model(api, uri, properties):
    """
    Transcribe a single audio file located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    # Model information (ADAPTED_ACOUSTIC_ID and ADAPTED_LANGUAGE_ID) must be set above.
    if MODEL_REFERENCE is None:
        logging.error("Custom model ids must be set when using custom models")
        sys.exit()

    model = api.get_model(MODEL_REFERENCE)

    transcription_definition = cris_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_urls=[uri],
        model=model,
        properties=properties
    )

    return transcription_definition


def transcribe_from_container(uri, properties, locale):
    """
    Transcribe all files in the container located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    transcription_definition = cris_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=locale,
        content_container_url=uri,
        properties=properties
    )

    return transcription_definition


def _paginate(api, paginated_object):
    """
    The autogenerated client does not support pagination. This function returns a generator over
    all items of the array that the paginated object `paginated_object` is part of.
    """
    yield from paginated_object.values
    typename = type(paginated_object).__name__
    auth_settings = ["apiKeyHeader", "apiKeyQuery"]
    while paginated_object.next_link:
        link = paginated_object.next_link[len(api.api_client.configuration.host):]
        paginated_object, status, headers = api.api_client.call_api(link, "GET",
            response_type=typename, auth_settings=auth_settings)

        if status == 200:
            yield from paginated_object.values
        else:
            raise Exception(f"could not receive paginated data: status {status}")


def delete_all_transcriptions(api):
    """
    Delete all transcriptions associated with your speech resource.
    """
    logging.info("Deleting all existing completed transcriptions.")

    # get all transcriptions for the subscription
    transcriptions = list(_paginate(api, api.get_transcriptions()))

    # Delete all pre-existing completed transcriptions.
    # If transcriptions are still running or not started, they will not be deleted.
    for transcription in transcriptions:
        transcription_id = transcription._self.split('/')[-1]
        logging.debug(f"Deleting transcription with id {transcription_id}")
        try:
            api.delete_transcription(transcription_id)
        except cris_client.rest.ApiException as exc:
            logging.error(f"Could not delete transcription {transcription_id}: {exc}")

def generate_sas_uri(recordings_container_uri=None, blob_name=None):

    blob_service_client = BlobServiceClient.from_connection_string(get_connection_string())

    container_client = blob_service_client.get_container_client("mycontainer")

    #If a blob_name was given, return sas of blob
    if blob_name:

        blob_sas_token = generate_blob_sas(
            account_name=container_client.account_name,
            container_name=container_client.container_name,
            blob_name=blob_name,
            account_key=container_client.credential.account_key,
            permission=ContainerSasPermissions(read=True),
            expiry=datetime.utcnow() + timedelta(hours=1)
        )

        blob_url_with_blob_sas_token = f"https://{container_client.account_name}.blob.core.windows.net/{container_client.container_name}/{blob_name}?{blob_sas_token}"
        return blob_url_with_blob_sas_token

    #if recordings_container_uri was given, return sas of containers
    if recordings_container_uri:
        container_sas_token = generate_container_sas(
            container_client.account_name,
            container_client.container_name,
            account_key=container_client.credential.account_key,
            policy_id='my-access-policy-id'
        )

        sas_uri =  recordings_container_uri + '?' + sas_token
        return sas_uri



def get_instance_transcription_api():

    # configure API key authorization: subscription_key
    configuration = cris_client.Configuration()
    configuration.api_key["Ocp-Apim-Subscription-Key"] = SUBSCRIPTION_KEY
    configuration.host = f"https://{SERVICE_REGION}.api.cognitive.microsoft.com/speechtotext/v3.0"

    # create the client object and authenticate
    client = cris_client.ApiClient(configuration)

    # create an instance of the transcription api class
    api = cris_client.DefaultApi(api_client=client)

    return api


def get_transcription_result(transcription_id, waiting_time=5):
    logging.info(f"Checking transcription status for {transcription_id}.")

    completed = False

    api = get_instance_transcription_api()

    while not completed:
        # wait for 5 seconds before refreshing the transcription status
        time.sleep(waiting_time)

        transcription = api.get_transcription(transcription_id)
        logging.info(f"Transcriptions status: {transcription.status}")

        print(f"Transcriptions status for {transcription_id}: {transcription.status}")
        if transcription.status in ("Failed", "Succeeded"):
            completed = True

        if transcription.status == "Succeeded":
            print(f'Transcription succeded for {transcription_id}')
            pag_files = api.get_transcription_files(transcription_id)

            #SHouldnt be more than one file right?
            for file_data in _paginate(api, pag_files):
                if file_data.kind != "Transcription":
                    continue

                audiofilename = file_data.name
                results_url = file_data.links.content_url
                results = requests.get(results_url)
                logging.info(f"Results for {audiofilename}:\n{results.content.decode('utf-8')}. results_url {results_url}")
                return results_url
        elif transcription.status == "Failed":
            print(f'Transcription failed for {transcription_id}')
            logging.info(f"Transcription failed: {transcription.properties.error.message}")
            return None


def launch_transcription(locale, blob_name = None, recordings_container_uri = None):

    logging.info("Starting transcription client...")

    api = get_instance_transcription_api()

    # Specify transcription properties by passing a dict to the properties parameter. See
    # https://docs.microsoft.com/azure/cognitive-services/speech-service/batch-transcription#configuration-properties
    # for supported parameters.
    properties = {
        "punctuationMode": "DictatedAndAutomatic"#,
        # "profanityFilterMode": "Masked",
        # "wordLevelTimestampsEnabled": True,
        # "diarizationEnabled": True#,
        # "destinationContainerUrl": "https://backchecker.blob.core.windows.net/transcriptionresults"
        # "timeToLive": "PT1H"
    }

    if blob_name:
        recordings_blob_uri = generate_sas_uri(blob_name=blob_name)
        transcription_definition = transcribe_from_single_blob(recordings_blob_uri, properties, locale)

    # Uncomment this block to use custom models for transcription.
    # transcription_definition = transcribe_with_custom_model(api, RECORDINGS_BLOB_URI, properties)

    elif recordings_container_uri:
        recordings_container_sas_uri = generate_sas_uri(recordings_container_uri)
        transcription_definition = transcribe_from_container(recordings_container_sas_uri, properties, locale)

    created_transcription, status, headers = api.create_transcription_with_http_info(transcription=transcription_definition)

    # get the transcription Id from the location URI
    transcription_id = headers["location"].split("/")[-1]

    # Log information about the created transcription. If you should ask for support, please
    # include this information.
    logging.info(f"Created new transcription with id '{transcription_id}' in region {SERVICE_REGION}")
    print(f"Created new transcription with id '{transcription_id}' in region {SERVICE_REGION}")

    return transcription_id


if __name__ == "__main__":
    transcribe()
